// ==UserScript==
// @name         SprechwunschBot - Mit Fortschrittsanzeige (stabil + Ticker + Retry + Leise)
// @namespace    https://deinprojekt.de/
// @version      1.3.0
// @description  Arbeitet Patienten- und Gefangenentransporte nacheinander ab, mit Status-Ticker (1 Zeile), Retry und Leise-Modus.
// @match        https://www.leitstellenspiel.de/*
// @grant        none
// ==/UserScript==

(function() {
  'use strict';

  // ===================== SETTINGS =====================
  const QUIET_MODE = true;        // true = keine Alerts (auch bei Fehler)
  const PRISON_RETRIES = 2;       // Anzahl Retry-Versuche (zus√§tzlich zum ersten Versuch)
  const PRISON_RETRY_PAUSE = 900; // Pause zwischen Retries in ms
  const AUTO_STOP_IF_EMPTY = true;

  // ===================== SELECTORS =====================
  const requestListSel = '#radio_messages_important';
  const vehicleLinkSel = 'a.lightbox-open:not(.mission-radio-button)';
  const patientBtnSel  = 'a.btn.btn-success[href*="/patient/"]';
  const prisonBtnSel   = 'a.btn.btn-success[data-prison-id]';
  const nextVehBtnSel  = '#next-vehicle-fms-5';

  // ===================== COUNTERS / STATE =====================
  let totalRequests = 0;
  let patientsDone = 0;
  let prisonersDone = 0;
  let skipped = 0;

  let botRunning = false;

  // ===================== HELPERS =====================
  function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

  async function fetchDoc(url) {
    const res = await fetch(url, { credentials: 'same-origin' });
    if (!res.ok) throw new Error(`Ladefehler ${res.status} bei ${url}`);
    const txt = await res.text();
    return new DOMParser().parseFromString(txt, 'text/html');
  }

  function updateProgress(extra = '') {
    const progressText =
  //    `üöë ${patientsDone}/${totalRequests} | üöì ${prisonersDone}/${totalRequests} | ‚è≠Ô∏è ${skipped}` +
      (extra ? ` | ${extra}` : '');
      `üöë ${patientsDone}/${totalRequests} | üöì ${prisonersDone}/${totalRequests}`+ (extra ? ` | ${extra}` : '');
    console.log('[SprechwunschBot]', progressText);

    const progressEl = document.getElementById('progress-status');
    if (progressEl) progressEl.textContent = progressText;
  }

  // ===================== TICKER (1 Zeile) =====================
  let tickerQueue = [];
  let tickerRunning = false;

  function ticker(msg) {
    tickerQueue.push(msg);
    if (!tickerRunning) runTicker();
  }

  async function runTicker() {
    tickerRunning = true;
    const el = document.getElementById('progress-ticker');

    while (tickerQueue.length) {
      const text = tickerQueue.shift();
      if (el) {
        el.textContent = text;
        el.style.transform = 'translateY(-5px)';
        await sleep(50);
        el.style.transform = 'translateY(0)';
      }
      await sleep(650);
    }

    tickerRunning = false;
  }

  // ===================== CORE LOOPS =====================
  async function followStatus5Loop(startDoc) {
    let doc = startDoc;

    // Guard, damit niemals Endlosschleife
    for (let guard = 0; guard < 80; guard++) {
      const nextBtn = doc.querySelector(nextVehBtnSel);
      if (!nextBtn || !nextBtn.href) return doc;

      doc = await fetchDoc(nextBtn.href);
      await sleep(120);
    }

    throw new Error('Status-5 Schleife abgebrochen (Guard-Limit erreicht).');
  }

  async function handlePatientTransport(baseUrl) {
    const doc = await fetchDoc(baseUrl);
    const btn = doc.querySelector(patientBtnSel);

    if (!btn || !btn.href) throw new Error('Kein Patienten-Transportbutton gefunden!');

    const nextDoc = await fetchDoc(btn.href);
    await followStatus5Loop(nextDoc);

    patientsDone++;
    updateProgress();
    return true;
  }

  async function handlePrisonTransport(baseUrl) {
    const url = baseUrl + (baseUrl.includes('?') ? '&' : '?') + 'load_all_prisons=true&show_only_available=true';
    const doc = await fetchDoc(url);

    const btn = doc.querySelector(prisonBtnSel);
    if (!btn || !btn.href) {
      // Kein "Fehler" -> einfach nichts zu tun
      ticker('‚è≠Ô∏è Kein Gefangenentransport verf√ºgbar');
      return false; // wichtig: NICHT als Skip z√§hlen
    }

    const nextDoc = await fetchDoc(btn.href);
    await followStatus5Loop(nextDoc);

    prisonersDone++;
    updateProgress();
    return true;
  }

  // ===================== MAIN =====================
  async function processAll() {
    if (botRunning) {
      ticker('‚õî Bot l√§uft bereits');
      return;
    }
    botRunning = true;

    ticker('‚ñ∂Ô∏è Abarbeitung gestartet');
    const failures = [];

    try {
      const list = document.querySelector(requestListSel);
      if (!list) throw new Error('Sprechw√ºnsche-Liste nicht gefunden!');

      const vehicleLinks = Array.from(list.querySelectorAll(vehicleLinkSel));
      totalRequests = vehicleLinks.length;
      patientsDone = 0;
      prisonersDone = 0;
      skipped = 0;

      updateProgress('‚ñ∂Ô∏è Start');

      if (AUTO_STOP_IF_EMPTY && totalRequests === 0) {
        ticker('üõë Keine Sprechw√ºnsche vorhanden ‚Äì Stop.');
        updateProgress('üõë Leer');
        return;
      }

      for (let i = 0; i < vehicleLinks.length; i++) {
        const href = vehicleLinks[i].href;
        updateProgress(`(${i + 1}/${totalRequests})`);

        // 1) Patient versuchen
        try {
          const doc = await fetchDoc(href);
          const patientBtn = doc.querySelector(patientBtnSel);

          if (patientBtn) {
            console.log('üöë Patienten-Transport:', href);
            ticker('üöë Patienten-Transport wird abgearbeitet');
            await handlePatientTransport(href);
            await sleep(250);
            continue;
          }
        } catch (e) {
          // ignorieren, danach Gefangene probieren
        }

        // 2) Gefangene mit Retry
        for (let attempt = 0; attempt <= PRISON_RETRIES; attempt++) {
          try {
            if (attempt > 0) {
              ticker(`üîÅ Retry Gefangene (${attempt}/${PRISON_RETRIES}) ‚Ä¶`);
              await sleep(PRISON_RETRY_PAUSE);
            }

            console.log(`üöì Gefangenentransport (Attempt ${attempt + 1}):`, href);
            ticker('üöì Gefangenentransport wird abgearbeitet');

            const done = await handlePrisonTransport(href);

            if (done === false) {
              // kein Transport vorhanden ‚Üí kein Skip, einfach weiter
              break;
            }

            // done === true ‚Üí fertig
            break;

          } catch (e) {
            if (attempt === PRISON_RETRIES) {
              skipped++;
              failures.push({ href, msg: e?.message || String(e) });
              console.warn('‚è≠Ô∏è √úbersprungen (Fehler):', href, e);
              updateProgress('‚ö†Ô∏è Skip');
              ticker('‚è≠Ô∏è Fehler beim Gefangenentransport');
            } else {
              console.warn('‚ö†Ô∏è Gefangenenversuch fehlgeschlagen, retry folgt:', href, e);
            }
          }
        }

        await sleep(250);
      }

      updateProgress('‚úÖ Fertig');
      ticker(`‚úÖ Fertig: ${patientsDone} üöë | ${prisonersDone} üöì | ${skipped} ‚è≠Ô∏è`);
      console.log('[SprechwunschBot] fertig', { patientsDone, prisonersDone, skipped, totalRequests });

      // Kein Reload (wie von dir gew√ºnscht)
      // window.location.reload();

    } catch (e) {
      console.error('Automatisierung abgebrochen:', e);
      ticker('‚ùå Abbruch: ' + (e?.message || String(e)));

      if (!QUIET_MODE) {
        alert('‚ùå ' + (e?.message || String(e)));
      }
    } finally {
      botRunning = false;

      if (failures.length) {
        console.group(`[SprechwunschBot] Failures: ${failures.length}`);
        failures.forEach(f => console.log(f.msg, f.href));
        console.groupEnd();
      }
    }
  }

  // ===================== UI =====================
  function addButton() {
    const header = document.querySelector('#radio_panel_heading .flex-row');
    if (!header || document.getElementById('invisible-auto-btn')) return;

    // Button
    const btn = document.createElement('button');
    btn.id = 'invisible-auto-btn';
    btn.textContent = 'Sprechw√ºnsche ‚ñ∂Ô∏è';
    btn.className = 'btn btn-primary btn-xs';
    btn.style.marginLeft = '10px';
    btn.title = 'Batch: Alle Sprechw√ºnsche/Transporte abarbeiten';
    btn.addEventListener('click', processAll);
    header.appendChild(btn);

    // Progress rechts neben Button
    const progressEl = document.createElement('span');
    progressEl.id = 'progress-status';
    progressEl.style.marginLeft = '15px';
    progressEl.style.fontWeight = 'bold';
    progressEl.style.color = '#0055aa';
    header.appendChild(progressEl);

    // Ticker: eigene Zeile UNTER den Buttons
    const old = document.getElementById('progress-ticker-wrap');
    if (old) old.remove();

    const wrap = document.createElement('div');
    wrap.id = 'progress-ticker-wrap';
    wrap.style.marginTop = '6px';
    wrap.style.padding = '4px 8px';
    wrap.style.borderTop = '1px solid rgba(0,0,0,0.08)';
    wrap.style.fontSize = '11px';
    wrap.style.color = '#333';
    wrap.style.whiteSpace = 'nowrap';
    wrap.style.overflow = 'hidden';
    wrap.style.textOverflow = 'ellipsis';

    // Zentrieren
    wrap.style.display = 'flex';
    wrap.style.justifyContent = 'center';

    const tickerEl = document.createElement('div');
    tickerEl.id = 'progress-ticker';
    tickerEl.textContent = 'Bereit.';
    tickerEl.style.transition = 'transform 120ms ease';
    tickerEl.style.textAlign = 'center';

    wrap.appendChild(tickerEl);

    // Direkt nach der Button-Zeile einf√ºgen
    header.insertAdjacentElement('afterend', wrap);

    // Initiale Anzeige
    updateProgress('Bereit');
  }

  new MutationObserver(addButton).observe(document.body, { childList: true, subtree: true });
  addButton();

})();
